# Dataclass `__init__` Extension Documentation

## Overview

This document explains the custom Griffe extension used to hide auto-generated `__init__` methods from dataclass documentation in our mkdocstrings-based API reference.

---

## The Problem

When documenting Python dataclasses with mkdocstrings, the auto-generated `__init__` method is displayed in the API documentation. This creates redundant information because:

1. **Dataclass attributes are already documented**: The class attributes are shown with their types as `instance-attribute` entries.
2. **Auto-generated `__init__` has no additional value**: For dataclasses, the `__init__` method is automatically generated by Python and simply assigns the attributes.
3. **Documentation bloat**: Users see the same parameter information twice - once as attributes and once in the `__init__` signature.

### Example of the Problem

Before this extension, a dataclass like:

```python
@dataclass
class ResolvedBackendSettings:
    """Resolved backend settings ready for use."""
    network: str
    bitcoin_network: str
    backend_type: str
```

Would produce documentation showing:

- Attributes: `network`, `bitcoin_network`, `backend_type` (correct, needed)
- Functions: `__init__(network, bitcoin_network, backend_type)` (redundant)

### Why mkdocstrings Does Not Solve This

Unlike pdoc3, which automatically detects dataclass decorators and hides auto-generated `__init__` methods, mkdocstrings treats all classes uniformly. There is no built-in option to conditionally hide `__init__` only for dataclasses.

A global filter like `filters: ["!__init__"]` would hide **all** `__init__` methods, including manually-written ones in regular classes that contain important constructor logic and documentation.

---

## The Solution

We created a custom Griffe extension that:

1. **Detects dataclasses**: Uses Griffe's built-in `dataclass` label to identify `@dataclass` decorated classes.
2. **Identifies auto-generated `__init__`**: Removes `__init__` only if it has no docstring (auto-generated methods have `None` as docstring).
3. **Preserves manual `__init__`**: If a developer writes a custom `__init__` with documentation, it will be preserved.

### Implementation

The extension is located at `docs/_extensions/hide_dataclass_init.py`:

```python
import griffe

class HideDataclassInit(griffe.Extension):
    """Remove auto-generated __init__ from dataclass documentation."""

    def on_class(self, *, cls: griffe.Class, **kwargs) -> None:
        # griffe labels dataclasses with "dataclass"
        if "dataclass" in cls.labels and "__init__" in cls.members:
            init_member = cls.members["__init__"]
            # Only remove if it has no user-written docstring
            if not init_member.docstring:
                del cls.members["__init__"]
```

### Configuration

The extension is registered in `mkdocs.yml`:

```yaml
plugins:
  - mkdocstrings:
      handlers:
        python:
          options:
            extensions:
              - docs/_extensions/hide_dataclass_init.py:HideDataclassInit
```

---

## How It Works

### Griffe Hooks

The extension uses the `on_class` hook, which is called after Griffe has fully analyzed a class. At this point:

- The `@dataclass` decorator has been detected and the class is labeled with `"dataclass"` in `cls.labels`
- Auto-generated `__init__` has been added to `cls.members` (if the dataclass has no custom `__init__`)
- We can safely remove it from the members dictionary

### Why We Check for Empty Docstring

```python
if not init_member.docstring:
    del cls.members["__init__"]
```

This check ensures we only remove **auto-generated** `__init__` methods. If a developer writes:

```python
@dataclass
class MyConfig:
    """Configuration class."""
    value: int
    
    def __init__(self, value: int):
        """Initialize with custom validation."""
        if value < 0:
            raise ValueError("value must be positive")
        self.value = value
```

The `__init__` will be **preserved** because it has a docstring.

---

## Future Maintenance

### When to Update This Extension

1. **Griffe API Changes**: If Griffe changes its Extension API or hook signatures.
2. **mkdocstrings-python Updates**: Major version updates might affect how Griffe is used.
3. **New Python Dataclass Features**: If Python adds new dataclass-related features that affect `__init__` generation.

### How to Test After Updates

1. Run `mkdocs serve` locally
2. Navigate to any dataclass documentation page
3. Verify `__init__` is not shown for simple dataclasses
4. Verify `__init__` IS shown for classes with custom `__init__` methods

### Debugging

To debug the extension, add print statements:

```python
def on_class(self, *, cls: griffe.Class, **kwargs) -> None:
    if "dataclass" in cls.labels:
        print(f"DEBUG: {cls.name} is a dataclass, members: {list(cls.members.keys())}")
        # ... rest of code
```

Then run `mkdocs serve` and check the console output.

---

## How to Remove This Extension

If this extension causes issues or becomes unnecessary, it can be removed in three ways:

### Option 1: Disable in Configuration (Quick)

Comment out or remove the extension in `mkdocs.yml`:

```yaml
plugins:
  - mkdocstrings:
      handlers:
        python:
          options:
            # extensions:
            #   - docs/_extensions/hide_dataclass_init.py:HideDataclassInit
```

**Effect**: `__init__` will be shown for all dataclasses again. No other functionality is affected.

### Option 2: Delete the Extension File

```bash
rm docs/_extensions/hide_dataclass_init.py
```

And remove the extension registration from `mkdocs.yml`.

### Option 3: Revert the Commit

```bash
git revert <commit-hash>
```

Where `<commit-hash>` is the commit that added the extension.

---

## Known Limitations

1. **Griffe Dependency**: The extension relies on Griffe's internal labeling of dataclasses. If Griffe changes this behavior, the extension may need updates.

2. **No Effect on Other Doc Tools**: This only affects mkdocstrings documentation. Tools like IDEs, `help()`, or other documentation generators will still show `__init__`.

3. **Custom `__init__` Detection**: We rely on docstring presence to detect custom `__init__`. A custom `__init__` without a docstring would be incorrectly hidden. This is considered acceptable since best practice is to document public methods.

---

## References

- [Griffe Documentation](https://mkdocstrings.github.io/griffe/)
- [mkdocstrings-python Documentation](https://mkdocstrings.github.io/python/)
- [Python dataclasses Module](https://docs.python.org/3/library/dataclasses.html)
- [GitHub Issue: mkdocstrings dataclass support](https://github.com/mkdocstrings/mkdocstrings/issues/116)

---

## History

- **2026-02-16**: Initial implementation to resolve redundant `__init__` documentation in dataclasses.
