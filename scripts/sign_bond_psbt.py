#!/usr/bin/env python3
"""Sign a fidelity bond spending PSBT using a hardware wallet via HWI.

This standalone script uses the Bitcoin Core Hardware Wallet Interface (HWI)
library to sign PSBTs generated by `jm-wallet spend-bond`. It communicates
directly with your hardware wallet (Trezor, Coldcard, Ledger, etc.) without
ever requiring the seed phrase.

Requirements:
    pip install hwi

Usage:
    # Interactive mode (enumerates devices, prompts for confirmation):
    python scripts/sign_bond_psbt.py <psbt_base64>

    # Or from a file:
    python scripts/sign_bond_psbt.py --file bond.psbt

    # Specify device type explicitly:
    python scripts/sign_bond_psbt.py --device-type trezor <psbt_base64>

    # Output signed transaction hex (ready for broadcast):
    python scripts/sign_bond_psbt.py <psbt_base64> | bitcoin-cli sendrawtransaction -

The script will:
    1. Enumerate connected hardware wallets
    2. Sign the PSBT using the device
    3. Output the fully signed transaction hex (ready to broadcast)
"""

from __future__ import annotations

import argparse
import base64
import sys


def check_hwi_installed() -> None:
    """Verify that HWI is installed."""
    try:
        import hwilib  # noqa: F401
    except ImportError:
        print(
            "ERROR: HWI (Hardware Wallet Interface) is not installed.\n"
            "\n"
            "Install it with:\n"
            "    pip install hwi\n"
            "\n"
            "HWI is the Bitcoin Core project's standard tool for hardware wallet\n"
            "communication. It supports Trezor, Coldcard, Ledger, and more.\n"
            "    https://github.com/bitcoin-core/HWI",
            file=sys.stderr,
        )
        sys.exit(1)


def enumerate_devices(device_type: str | None = None) -> list[dict]:
    """Find connected hardware wallets.

    Args:
        device_type: Optional filter for device type (e.g., "trezor", "coldcard").

    Returns:
        List of device info dicts from HWI.
    """
    from hwilib.commands import enumerate as hwi_enumerate

    devices = hwi_enumerate()

    if device_type:
        devices = [d for d in devices if d.get("type") == device_type]

    return devices


def sign_psbt(device: dict, psbt_b64: str, chain: str = "main") -> dict:
    """Sign a PSBT using the specified hardware wallet device.

    Args:
        device: Device info dict from HWI enumerate.
        psbt_b64: Base64-encoded PSBT string.
        chain: Bitcoin network ("main", "test", "signet", "regtest").

    Returns:
        Dict with 'psbt' key containing the signed PSBT base64.

    Raises:
        RuntimeError: If signing fails.
    """
    from hwilib.commands import get_client, signtx
    from hwilib.common import Chain

    chain_map = {
        "main": Chain.MAIN,
        "test": Chain.TEST,
        "signet": Chain.SIGNET,
        "regtest": Chain.REGTEST,
    }
    hwi_chain = chain_map.get(chain, Chain.MAIN)

    client = get_client(device["type"], device["path"], chain=hwi_chain)
    try:
        result = signtx(client, psbt_b64)
        if "error" in result:
            raise RuntimeError(f"HWI signing error: {result['error']}")
        return result
    finally:
        client.close()


def finalize_psbt(signed_psbt_b64: str) -> str | None:
    """Try to finalize a signed PSBT and extract the raw transaction hex.

    Uses bitcoin-lib if available, otherwise returns None and the user
    should finalize via bitcoin-cli or Sparrow.

    Args:
        signed_psbt_b64: Base64-encoded signed PSBT.

    Returns:
        Hex-encoded raw transaction if finalization succeeded, else None.
    """
    # Try using bitcoin-cli for finalization
    import shutil
    import subprocess

    bitcoin_cli = shutil.which("bitcoin-cli")
    if bitcoin_cli:
        try:
            result = subprocess.run(
                [bitcoin_cli, "finalizepsbt", signed_psbt_b64],
                capture_output=True,
                text=True,
                timeout=10,
            )
            if result.returncode == 0:
                import json

                data = json.loads(result.stdout)
                if data.get("complete"):
                    return data["hex"]
        except (subprocess.TimeoutExpired, json.JSONDecodeError, KeyError):
            pass

    return None


def detect_network_from_psbt(psbt_b64: str) -> str:
    """Try to detect the network from the PSBT content.

    Examines the output addresses/scripts to guess the network.
    Falls back to "main" if detection fails.

    Args:
        psbt_b64: Base64-encoded PSBT.

    Returns:
        Network string for HWI: "main", "test", "signet", or "regtest".
    """
    try:
        raw = base64.b64decode(psbt_b64)
        # Look for bech32 address prefixes in the raw bytes
        if b"bcrt" in raw:
            return "regtest"
        if b"tb1" in raw:
            return "test"
    except Exception:
        pass
    return "main"


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Sign a fidelity bond spending PSBT with a hardware wallet via HWI.",
        epilog=(
            "Examples:\n"
            "  %(prog)s cHNidP8BAF4...\n"
            "  %(prog)s --file bond.psbt\n"
            "  %(prog)s --device-type trezor cHNidP8BAF4...\n"
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "psbt",
        nargs="?",
        help="Base64-encoded PSBT string",
    )
    parser.add_argument(
        "--file",
        "-f",
        type=str,
        help="Read PSBT from file instead of command line argument",
    )
    parser.add_argument(
        "--device-type",
        "-t",
        type=str,
        help="Hardware wallet type (e.g., trezor, coldcard, ledger)",
    )
    parser.add_argument(
        "--chain",
        "-c",
        type=str,
        choices=["main", "test", "signet", "regtest"],
        default=None,
        help="Bitcoin network (default: auto-detect from PSBT)",
    )
    parser.add_argument(
        "--no-broadcast",
        action="store_true",
        help="Only output the signed PSBT, don't try to finalize or broadcast",
    )

    args = parser.parse_args()

    # Get the PSBT
    if args.file:
        try:
            with open(args.file) as f:
                psbt_b64 = f.read().strip()
        except FileNotFoundError:
            print(f"ERROR: File not found: {args.file}", file=sys.stderr)
            sys.exit(1)
    elif args.psbt:
        psbt_b64 = args.psbt.strip()
    else:
        parser.print_help()
        sys.exit(1)

    # Validate PSBT format
    try:
        raw = base64.b64decode(psbt_b64)
        if not raw.startswith(b"psbt\xff"):
            print("ERROR: Invalid PSBT (missing magic bytes)", file=sys.stderr)
            sys.exit(1)
    except Exception:
        print("ERROR: Invalid base64 encoding", file=sys.stderr)
        sys.exit(1)

    # Check HWI is installed
    check_hwi_installed()

    # Auto-detect network if not specified
    chain = args.chain or detect_network_from_psbt(psbt_b64)
    print(f"Network: {chain}", file=sys.stderr)

    # Enumerate devices
    print("Searching for hardware wallets...", file=sys.stderr)
    devices = enumerate_devices(args.device_type)

    if not devices:
        if args.device_type:
            print(
                f"ERROR: No {args.device_type} device found. "
                "Make sure it's connected and unlocked.",
                file=sys.stderr,
            )
        else:
            print(
                "ERROR: No hardware wallet found.\n"
                "Make sure your device is:\n"
                "  - Connected via USB\n"
                "  - Unlocked (PIN entered)\n"
                "  - Not in use by another application (close Sparrow first!)",
                file=sys.stderr,
            )
        sys.exit(1)

    # Select device
    if len(devices) == 1:
        device = devices[0]
        print(
            f"Found: {device.get('type', 'unknown')} "
            f"(fingerprint: {device.get('fingerprint', 'unknown')})",
            file=sys.stderr,
        )
    else:
        print(f"Found {len(devices)} devices:", file=sys.stderr)
        for i, d in enumerate(devices):
            print(
                f"  [{i}] {d.get('type', 'unknown')} "
                f"(fingerprint: {d.get('fingerprint', 'unknown')})",
                file=sys.stderr,
            )

        try:
            choice = int(input("Select device number: "))
            device = devices[choice]
        except (ValueError, IndexError):
            print("ERROR: Invalid selection", file=sys.stderr)
            sys.exit(1)

    # Sign the PSBT
    print("Signing PSBT... (confirm on your hardware wallet)", file=sys.stderr)
    try:
        result = sign_psbt(device, psbt_b64, chain=chain)
    except RuntimeError as e:
        print(f"ERROR: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"ERROR: Unexpected error during signing: {e}", file=sys.stderr)
        sys.exit(1)

    signed_psbt = result.get("psbt", "")
    if not signed_psbt:
        print("ERROR: No signed PSBT returned from device", file=sys.stderr)
        sys.exit(1)

    print("PSBT signed successfully!", file=sys.stderr)

    if args.no_broadcast:
        # Output just the signed PSBT
        print(signed_psbt)
        return

    # Try to finalize and extract raw tx
    print("Finalizing transaction...", file=sys.stderr)
    tx_hex = finalize_psbt(signed_psbt)

    if tx_hex:
        print("\n" + "=" * 80, file=sys.stderr)
        print("SIGNED TRANSACTION (hex):", file=sys.stderr)
        print("=" * 80, file=sys.stderr)
        print(tx_hex)
        print("=" * 80, file=sys.stderr)
        print(
            "\nBroadcast with:\n"
            f"  bitcoin-cli sendrawtransaction {tx_hex}\n"
            "\nOr paste into Sparrow: Tools -> Broadcast Transaction",
            file=sys.stderr,
        )
    else:
        print("\n" + "=" * 80, file=sys.stderr)
        print("SIGNED PSBT (base64):", file=sys.stderr)
        print("=" * 80, file=sys.stderr)
        print(signed_psbt)
        print("=" * 80, file=sys.stderr)
        print(
            "\nCould not auto-finalize. To finalize and broadcast:\n"
            "  bitcoin-cli finalizepsbt <signed_psbt_base64>\n"
            "\nOr import into Sparrow: File -> Open Transaction -> From Text",
            file=sys.stderr,
        )


if __name__ == "__main__":
    main()
